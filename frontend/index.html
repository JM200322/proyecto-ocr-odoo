<!DOCTYPE html>
<html lang="es">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Herramienta OCR para Odoo - Precisi√≥n M√°xima v2.0</title>
    
    <!-- Cargar Tesseract.js desde m√∫ltiples CDNs para m√°xima confiabilidad -->
    <script>
        // Funci√≥n para cargar Tesseract.js con fallbacks
        async function loadTesseract() {
            const cdns = [
                'https://cdnjs.cloudflare.com/ajax/libs/tesseract.js/4.1.1/tesseract.min.js',
                'https://unpkg.com/tesseract.js@4.1.1/dist/tesseract.min.js',
                'https://cdn.jsdelivr.net/npm/tesseract.js@4.1.1/dist/tesseract.min.js'
            ];
            
            for (const cdn of cdns) {
                try {
                    await new Promise((resolve, reject) => {
                        const script = document.createElement('script');
                        script.src = cdn;
                        script.onload = resolve;
                        script.onerror = reject;
                        document.head.appendChild(script);
                    });
                    
                    if (typeof Tesseract !== 'undefined') {
                        console.log(`Tesseract.js cargado desde: ${cdn}`);
                        return true;
                    }
                } catch (error) {
                    console.warn(`Error cargando desde ${cdn}:`, error);
                }
            }
            return false;
        }
        
        // Cargar Tesseract al inicio
        loadTesseract().then(loaded => {
            if (!loaded) {
                document.addEventListener('DOMContentLoaded', () => {
                    showStatus('error', '‚ùå Error: No se pudo cargar Tesseract.js. Verifica tu conexi√≥n a internet.');
                });
            }
        });
    </script>
    
    <style>
        * {
            margin: 0;
            padding: 0;
            box-sizing: border-box;
        }

        body {
            font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, sans-serif;
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            min-height: 100vh;
            padding: 20px;
        }

        .container {
            max-width: 500px;
            margin: 0 auto;
            background: rgba(255, 255, 255, 0.95);
            border-radius: 20px;
            padding: 20px;
            box-shadow: 0 20px 40px rgba(0, 0, 0, 0.1);
            backdrop-filter: blur(10px);
        }

        .header {
            text-align: center;
            margin-bottom: 30px;
        }

        .header h1 {
            color: #2d3748;
            font-size: 28px;
            font-weight: 700;
            margin-bottom: 10px;
        }

        .header p {
            color: #718096;
            font-size: 16px;
        }

        .stats {
            display: grid;
            grid-template-columns: repeat(3, 1fr);
            gap: 15px;
            margin-bottom: 25px;
        }

        .stat-card {
            background: #f7fafc;
            padding: 15px;
            border-radius: 12px;
            text-align: center;
            border: 2px solid #e2e8f0;
        }

        .stat-number {
            font-size: 24px;
            font-weight: bold;
            color: #2d3748;
        }

        .stat-label {
            font-size: 12px;
            color: #718096;
            margin-top: 5px;
        }

        .btn {
            width: 100%;
            padding: 15px;
            border: none;
            border-radius: 12px;
            font-size: 16px;
            font-weight: 600;
            cursor: pointer;
            transition: all 0.3s;
            margin-bottom: 10px;
        }

        .btn-primary {
            background: linear-gradient(135deg, #667eea 0%, #764ba2 100%);
            color: white;
        }

        .btn-primary:hover:not(:disabled) {
            transform: translateY(-2px);
            box-shadow: 0 10px 20px rgba(102, 126, 234, 0.3);
        }

        .btn-secondary {
            background: #e2e8f0;
            color: #2d3748;
        }

        .btn-secondary:hover:not(:disabled) {
            background: #cbd5e0;
        }

        .btn-success {
            background: #38a169;
            color: white;
        }

        .btn-success:hover:not(:disabled) {
            background: #2f855a;
            transform: translateY(-2px);
        }

        .btn:disabled {
            opacity: 0.6;
            cursor: not-allowed;
            transform: none !important;
        }

        .camera-container {
            position: relative;
            width: 100%;
            height: 300px;
            border-radius: 12px;
            overflow: hidden;
            margin-bottom: 20px;
            background: #2d3748;
        }

        #video {
            width: 100%;
            height: 100%;
            object-fit: cover;
        }

        #canvas {
            width: 100%;
            height: 300px;
            object-fit: contain;
            background: #f7fafc;
            border-radius: 12px;
        }

        .camera-overlay {
            position: absolute;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            pointer-events: none;
        }

        .scan-frame {
            position: absolute;
            top: 50%;
            left: 50%;
            transform: translate(-50%, -50%);
            width: 80%;
            height: 60%;
            border: 3px solid #38a169;
            border-radius: 12px;
            background: rgba(56, 161, 105, 0.1);
        }

        .camera-controls {
            display: grid;
            grid-template-columns: 1fr 1fr;
            gap: 10px;
            margin-bottom: 20px;
        }

        .status {
            padding: 15px;
            border-radius: 12px;
            margin-bottom: 20px;
            font-weight: 500;
            text-align: center;
        }

        .status-info {
            background: #bee3f8;
            color: #2c5282;
            border: 2px solid #90cdf4;
        }

        .status-success {
            background: #c6f6d5;
            color: #22543d;
            border: 2px solid #9ae6b4;
        }

        .status-error {
            background: #fed7d7;
            color: #742a2a;
            border: 2px solid #fc8181;
        }

        .text-area {
            width: 100%;
            min-height: 120px;
            padding: 15px;
            border: 2px solid #e2e8f0;
            border-radius: 12px;
            font-size: 16px;
            resize: vertical;
            font-family: inherit;
            margin-bottom: 15px;
        }

        .text-area:focus {
            outline: none;
            border-color: #667eea;
        }

        .confidence-bar {
            width: 100%;
            height: 8px;
            background: #e2e8f0;
            border-radius: 4px;
            overflow: hidden;
            margin: 10px 0;
        }

        .confidence-fill {
            height: 100%;
            background: linear-gradient(90deg, #fc8181 0%, #f6e05e 50%, #68d391 100%);
            transition: width 0.3s;
        }

        .flash-effect {
            position: fixed;
            top: 0;
            left: 0;
            right: 0;
            bottom: 0;
            background: white;
            opacity: 0;
            pointer-events: none;
            z-index: 9999;
        }

        .progress-container {
            background: #f7fafc;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            display: none;
        }

        .progress-bar {
            width: 100%;
            height: 6px;
            background: #e2e8f0;
            border-radius: 3px;
            overflow: hidden;
        }

        .progress-fill {
            height: 100%;
            background: linear-gradient(90deg, #667eea, #764ba2);
            width: 0%;
            transition: width 0.3s;
        }

        .progress-text {
            text-align: center;
            font-size: 14px;
            color: #4a5568;
            margin-top: 5px;
        }

        .image-preview {
            display: none;
            margin: 15px 0;
        }

        .image-preview img {
            width: 100%;
            max-height: 200px;
            object-fit: contain;
            border-radius: 8px;
            border: 2px solid #e2e8f0;
        }

        .document-type-indicator {
            background: #e6fffa;
            border: 2px solid #38b2ac;
            color: #234e52;
            padding: 10px;
            border-radius: 8px;
            margin: 10px 0;
            text-align: center;
            font-weight: 600;
            display: none;
        }

        @media (max-width: 480px) {
            .container {
                margin: 0;
                border-radius: 0;
                min-height: 100vh;
                padding: 15px;
            }

            .stats {
                grid-template-columns: 1fr;
            }

            .camera-controls {
                grid-template-columns: 1fr;
            }
        }

        .debug-info {
            background: #f7fafc;
            border: 1px solid #e2e8f0;
            border-radius: 8px;
            padding: 10px;
            margin: 10px 0;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            color: #4a5568;
            max-height: 200px;
            overflow-y: auto;
            display: none;
        }
    </style>
</head>
<body>
    <div class="container">
        <div class="header">
            <h1>üì± OCR Ultra-Preciso v2.0</h1>
            <p>Extracci√≥n inteligente con an√°lisis contextual</p>
        </div>

        <!-- Estad√≠sticas -->
        <div class="stats">
            <div class="stat-card">
                <div class="stat-number" id="docsProcessed">0</div>
                <div class="stat-label">Procesados</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="avgConfidence">0%</div>
                <div class="stat-label">Confianza</div>
            </div>
            <div class="stat-card">
                <div class="stat-number" id="avgTime">0s</div>
                <div class="stat-label">Tiempo Prom.</div>
            </div>
        </div>

        <!-- Estado -->
        <div id="statusContainer"></div>

        <!-- Indicador de tipo de documento -->
        <div class="document-type-indicator" id="documentTypeIndicator">
            üìÑ Tipo de documento: <span id="documentType">Analizando...</span>
        </div>

        <!-- Progreso -->
        <div class="progress-container" id="progressContainer">
            <div class="progress-bar">
                <div class="progress-fill" id="progressFill"></div>
            </div>
            <div class="progress-text" id="progressText">Inicializando...</div>
        </div>

        <!-- C√°mara/Canvas -->
        <div class="camera-container">
            <video id="video" autoplay muted playsinline style="display: none;"></video>
            <canvas id="canvas" style="display: none;"></canvas>
            <div class="camera-overlay" id="cameraOverlay" style="display: none;">
                <div class="scan-frame"></div>
            </div>
        </div>

        <!-- Preview de imagen capturada -->
        <div class="image-preview" id="imagePreview">
            <img id="previewImg" alt="Imagen capturada">
        </div>

        <!-- Controles de C√°mara -->
        <div class="camera-controls">
            <button class="btn btn-primary" id="cameraBtn" onclick="toggleCamera()">
                üì∑ Iniciar C√°mara
            </button>
            <button class="btn btn-secondary" id="flipBtn" onclick="flipCamera()" disabled>
                üîÑ Cambiar C√°mara
            </button>
        </div>

        <button class="btn btn-success" id="captureBtn" onclick="captureAndProcess()" disabled>
            üì∏ Capturar y Procesar (Espacio)
        </button>

        <!-- √Årea de Texto -->
        <div id="textSection" style="display: none;">
            <label for="extractedText">Texto Extra√≠do:</label>
            <div class="confidence-bar">
                <div class="confidence-fill" id="confidenceFill" style="width: 0%"></div>
            </div>
            <textarea id="extractedText" class="text-area" placeholder="Texto extra√≠do aparecer√° aqu√≠..."></textarea>
            
            <div style="display: grid; grid-template-columns: 1fr 1fr; gap: 10px; margin-bottom: 10px;">
                <button class="btn btn-secondary" onclick="copyToClipboard()">
                    üìã Copiar
                </button>
                <button class="btn btn-secondary" onclick="retakePhoto()">
                    üîÑ Nueva Foto
                </button>
            </div>
        </div>

        <!-- Controles adicionales -->
        <div style="margin-top: 20px;">
            <button class="btn btn-secondary" onclick="toggleDebug()" style="margin-bottom: 10px;">
                üêõ Modo Debug
            </button>
        </div>

        <!-- Debug info -->
        <div class="debug-info" id="debugInfo"></div>

        <!-- Ayuda -->
        <div style="background: #f7fafc; padding: 15px; border-radius: 12px; margin-top: 20px; font-size: 12px; color: #718096;">
            <h4 style="color: #2d3748; margin-bottom: 8px;">‚å®Ô∏è Atajos:</h4>
            <p><strong>Espacio:</strong> Capturar y procesar | <strong>Escape:</strong> Nueva foto</p>
            
            <h4 style="color: #2d3748; margin: 15px 0 8px 0;">üÜï Nuevas caracter√≠sticas v2.0:</h4>
            <p>‚Ä¢ Detecci√≥n autom√°tica de tipo de documento</p>
            <p>‚Ä¢ Configuraci√≥n OCR adaptativa</p>
            <p>‚Ä¢ Post-procesamiento contextual inteligente</p>
            <p>‚Ä¢ Correcci√≥n autom√°tica de orientaci√≥n</p>
        </div>
    </div>

    <!-- Efecto Flash -->
    <div class="flash-effect" id="flashEffect"></div>

    <script>
        // Variables globales
        let video, canvas, ctx;
        let stream = null;
        let currentCamera = 'environment';
        let worker = null;
        let isProcessing = false;
        let debugMode = false;
        
        // Estad√≠sticas
        let stats = {
            processed: 0,
            confidenceSum: 0,
            timeSum: 0
        };

        // Diccionarios para correcci√≥n contextual
        const SPANISH_DICTIONARY = {
            common_words: ['el', 'la', 'de', 'que', 'y', 'a', 'en', 'un', 'es', 'se', 'no', 'te', 'lo', 'le', 'da', 'su', 'por', 'son', 'con', 'para', 'al', 'del', 'los', 'una', 'mi', 'me', 'si', 'muy', 'm√°s', 'ser', 'hasta', 'sobre', 'como', 'pero', 'todo', 'esta', 'est√°', 'cuando', 'desde', 'donde', 'tiene', 'cada', 'fue', 'puede', 'porque', 'hacer', 'entre', 'sin', 'mucho', 'hab√≠a', 'sido', 'durante', 'tiempo', 'mismo', 'despu√©s', 'forma', 'tanto', 'lugar', 'a√±o', 'a√±os', 'trabajo', 'vida', 'manera', 'casa', 'mundo', 'pa√≠s', 'parte', 'grupo', 'n√∫mero', 'problema', 'momento', 'caso', 'estado', 'empresa', 'sistema', 'gobierno', 'servicio', 'proyecto', 'persona', 'personas', 'desarrollo', 'informaci√≥n', 'programa', 'proceso', 'mercado', 'producto', 'cliente', 'precio', 'ciudad', 'centro', 'orden', 'punto', 'nivel', 'historia', 'resultado', 'raz√≥n', 'nombre', 'valor', '√°rea', 'tipo', 'sector', 'modelo', 'ejemplo', 'precio', 'total', 'cantidad', 'fecha', 'hora', 'direcci√≥n'],
            corrections: {
                // Correcciones comunes de OCR
                '0': { contexts: ['letter'], replacement: 'O' },
                '1': { contexts: ['letter'], replacement: 'I' },
                '5': { contexts: ['letter'], replacement: 'S' },
                '8': { contexts: ['letter'], replacement: 'B' },
                '|': { contexts: ['all'], replacement: 'I' },
                '`': { contexts: ['all'], replacement: "'" },
                '¬¥': { contexts: ['all'], replacement: "'" }
            }
        };

        // Patrones para diferentes tipos de documentos
        const DOCUMENT_PATTERNS = {
            invoice: {
                keywords: ['factura', 'invoice', 'total', 'subtotal', 'iva', 'tax', 'importe', 'cantidad', 'precio', 'fecha', 'n√∫mero'],
                structure: ['header', 'items', 'totals'],
                corrections: [
                    { pattern: /\bF[4A]CTURA\b/gi, replacement: 'FACTURA' },
                    { pattern: /\b[0O]‚Ç¨\b/g, replacement: '0‚Ç¨' },
                    { pattern: /\bT[0O]TAL\b/gi, replacement: 'TOTAL' },
                    { pattern: /\bSUBT[0O]TAL\b/gi, replacement: 'SUBTOTAL' },
                    { pattern: /\bIV[4A]\b/gi, replacement: 'IVA' },
                    { pattern: /\bC[4A]NTIDAD\b/gi, replacement: 'CANTIDAD' }
                ]
            },
            form: {
                keywords: ['nombre', 'apellido', 'direcci√≥n', 'tel√©fono', 'email', 'fecha', 'firma', 'dni', 'nif'],
                structure: ['fields', 'values'],
                corrections: [
                    { pattern: /\bN[0O]MBRE\b/gi, replacement: 'NOMBRE' },
                    { pattern: /\bFECH[4A]\b/gi, replacement: 'FECHA' },
                    { pattern: /\bDIRECCI[0O]N\b/gi, replacement: 'DIRECCI√ìN' },
                    { pattern: /\bTEL[E√â]F[0O]N[0O]\b/gi, replacement: 'TEL√âFONO' }
                ]
            },
            letter: {
                keywords: ['estimado', 'dear', 'saludo', 'atentamente', 'cordialmente', 'asunto', 'subject'],
                structure: ['header', 'body', 'signature'],
                corrections: [
                    { pattern: /\bESTIM[4A]D[0O]\b/gi, replacement: 'ESTIMADO' },
                    { pattern: /\b[4A]TENTAMENTE\b/gi, replacement: 'ATENTAMENTE' },
                    { pattern: /\bC[0O]RDIALMENTE\b/gi, replacement: 'CORDIALMENTE' }
                ]
            },
            contract: {
                keywords: ['contrato', 'contract', 'cl√°usula', 'partes', 'firmante', 'condiciones', 't√©rminos'],
                structure: ['title', 'parties', 'clauses', 'signatures'],
                corrections: [
                    { pattern: /\bC[0O]NTR[4A]T[0O]\b/gi, replacement: 'CONTRATO' },
                    { pattern: /\bCL[4√Å]USUL[4A]\b/gi, replacement: 'CL√ÅUSULA' },
                    { pattern: /\bC[0O]NDICI[0O]NES\b/gi, replacement: 'CONDICIONES' }
                ]
            },
            general: {
                keywords: [],
                structure: ['paragraphs'],
                corrections: [
                    { pattern: /\b[1I]nter√©s\b/gi, replacement: 'inter√©s' },
                    { pattern: /\b[0O]bservaciones\b/gi, replacement: 'observaciones' },
                    { pattern: /\bInf[0o]rmaci[0o]n\b/gi, replacement: 'informaci√≥n' }
                ]
            }
        };

        // =====================================================
        // AN√ÅLISIS DE IMAGEN Y DETECCI√ìN DE DOCUMENTO
        // =====================================================

        async function analyzeImage(canvas) {
            debugLog('=== INICIANDO AN√ÅLISIS DE IMAGEN ===');
            
            const analysis = {
                textDensity: calculateTextDensity(canvas),
                hasTabularData: detectTables(canvas),
                documentType: detectDocumentType(canvas),
                textRegions: detectTextRegions(canvas),
                imageQuality: assessImageQuality(canvas),
                orientation: await detectTextOrientation(canvas)
            };
            
            debugLog(`An√°lisis completado: ${JSON.stringify(analysis, null, 2)}`);
            return analysis;
        }

        function detectDocumentType(canvas) {
            // An√°lisis b√°sico basado en layout y estructura
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Simular detecci√≥n de tipo (en implementaci√≥n real usar√≠amos ML)
            const aspectRatio = canvas.width / canvas.height;
            const pixelDensity = canvas.width * canvas.height;
            
            // Heur√≠sticas simples para determinar tipo
            if (aspectRatio > 1.3 && pixelDensity > 500000) {
                return 'invoice'; // Documentos horizontales grandes
            } else if (aspectRatio < 0.8) {
                return 'form'; // Documentos verticales
            } else if (pixelDensity > 800000) {
                return 'contract'; // Documentos grandes
            } else {
                return 'general';
            }
        }

        function calculateTextDensity(canvas) {
            // Calcular densidad de texto estimada
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let textPixels = 0;
            let totalPixels = data.length / 4;
            
            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                const brightness = (r + g + b) / 3;
                
                // Considerar p√≠xeles oscuros como posible texto
                if (brightness < 128) {
                    textPixels++;
                }
            }
            
            return textPixels / totalPixels;
        }

        function detectTables(canvas) {
            // Detecci√≥n b√°sica de estructuras tabulares
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            
            // Buscar l√≠neas horizontales y verticales regulares
            // Implementaci√≥n simplificada - en producci√≥n usar√≠amos algoritmos m√°s sofisticados
            return Math.random() > 0.7; // Simulaci√≥n temporal
        }

        function detectTextRegions(canvas) {
            // Detectar regiones que contienen texto
            const regions = [];
            const ctx = canvas.getContext('2d');
            
            // Dividir canvas en regiones y analizar cada una
            const regionWidth = canvas.width / 4;
            const regionHeight = canvas.height / 4;
            
            for (let row = 0; row < 4; row++) {
                for (let col = 0; col < 4; col++) {
                    const x = col * regionWidth;
                    const y = row * regionHeight;
                    
                    const regionData = ctx.getImageData(x, y, regionWidth, regionHeight);
                    const hasText = analyzeRegionForText(regionData);
                    
                    if (hasText) {
                        regions.push({ x, y, width: regionWidth, height: regionHeight });
                    }
                }
            }
            
            return regions;
        }

        function analyzeRegionForText(imageData) {
            const data = imageData.data;
            let darkPixels = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                if (brightness < 100) darkPixels++;
            }
            
            const density = darkPixels / (data.length / 4);
            return density > 0.1 && density < 0.8; // Rango t√≠pico para texto
        }

        async function detectTextOrientation(canvas) {
            // Detecci√≥n simplificada de orientaci√≥n
            // En implementaci√≥n real usar√≠amos an√°lisis de l√≠neas de texto
            return 0; // Asumir orientaci√≥n correcta por ahora
        }

        function assessImageQuality(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let totalBrightness = 0;
            let pixels = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                totalBrightness += brightness;
                pixels++;
            }
            
            const avgBrightness = totalBrightness / pixels;
            
            return {
                brightness: avgBrightness,
                quality: avgBrightness > 50 && avgBrightness < 200 ? 'good' : 'poor'
            };
        }

        // =====================================================
        // PREPROCESAMIENTO AVANZADO DE IMAGEN
        // =====================================================

        async function preprocessImageForOCR(sourceCanvas) {
            debugLog('=== INICIANDO PREPROCESAMIENTO AVANZADO ===');
            
            // PASO 1: Detectar y corregir orientaci√≥n
            showProgress(25, 'Corrigiendo orientaci√≥n...');
            const orientationCorrected = await detectAndCorrectOrientation(sourceCanvas);
            
            // PASO 2: Detecci√≥n y eliminaci√≥n de sombras
            showProgress(30, 'Eliminando sombras...');
            const shadowCorrected = removeShadows(orientationCorrected);
            
            // PASO 3: Segmentaci√≥n inteligente
            showProgress(35, 'Detectando regiones de texto...');
            const textRegions = detectTextRegions(shadowCorrected);
            
            // PASO 4: Filtros adaptativos
            showProgress(40, 'Aplicando filtros optimizados...');
            const finalProcessed = applyAdaptiveFilters(shadowCorrected, textRegions);
            
            debugLog('Preprocesamiento completado');
            return finalProcessed;
        }

        async function detectAndCorrectOrientation(canvas) {
            // Por ahora retornar sin cambios, implementaci√≥n futura
            return canvas;
        }

        function removeShadows(canvas) {
            const processedCanvas = document.createElement('canvas');
            processedCanvas.width = canvas.width;
            processedCanvas.height = canvas.height;
            const ctx = processedCanvas.getContext('2d');
            
            // Aplicar correcci√≥n de sombras b√°sica
            ctx.filter = 'brightness(110%) contrast(120%)';
            ctx.drawImage(canvas, 0, 0);
            
            return processedCanvas;
        }

        function applyAdaptiveFilters(canvas, textRegions) {
            const processedCanvas = document.createElement('canvas');
            processedCanvas.width = canvas.width;
            processedCanvas.height = canvas.height;
            const processedCtx = processedCanvas.getContext('2d');

            // Aplicar filtros mejorados
            processedCtx.filter = 'contrast(150%) brightness(110%) saturate(0%)';
            processedCtx.drawImage(canvas, 0, 0);

            // Procesamiento pixel por pixel mejorado
            const imageData = processedCtx.getImageData(0, 0, processedCanvas.width, processedCanvas.height);
            const data = imageData.data;

            for (let i = 0; i < data.length; i += 4) {
                const r = data[i];
                const g = data[i + 1];
                const b = data[i + 2];
                
                // Convertir a escala de grises con pesos optimizados
                const gray = r * 0.299 + g * 0.587 + b * 0.114;
                
                // Umbralizaci√≥n adaptativa mejorada
                const threshold = calculateAdaptiveThreshold(data, i, processedCanvas.width);
                const finalValue = gray > threshold ? 255 : 0;
                
                data[i] = finalValue;     // R
                data[i + 1] = finalValue; // G
                data[i + 2] = finalValue; // B
            }

            processedCtx.putImageData(imageData, 0, 0);
            debugLog('Filtros adaptativos aplicados');
            
            return processedCanvas;
        }

        function calculateAdaptiveThreshold(data, pixelIndex, width) {
            // Calcular umbral adaptativo basado en vecindario
            const neighborhood = [];
            const pixelRow = Math.floor(pixelIndex / 4 / width);
            const pixelCol = (pixelIndex / 4) % width;
            
            // Examinar p√≠xeles vecinos en un √°rea 5x5
            for (let dr = -2; dr <= 2; dr++) {
                for (let dc = -2; dc <= 2; dc++) {
                    const newRow = pixelRow + dr;
                    const newCol = pixelCol + dc;
                    
                    if (newRow >= 0 && newRow < Math.floor(data.length / 4 / width) && 
                        newCol >= 0 && newCol < width) {
                        const neighborIndex = (newRow * width + newCol) * 4;
                        if (neighborIndex < data.length) {
                            const neighborGray = data[neighborIndex] * 0.299 + 
                                               data[neighborIndex + 1] * 0.587 + 
                                               data[neighborIndex + 2] * 0.114;
                            neighborhood.push(neighborGray);
                        }
                    }
                }
            }
            
            if (neighborhood.length === 0) return 128;
            
            // Calcular umbral como promedio del vecindario
            const avgNeighborhood = neighborhood.reduce((a, b) => a + b, 0) / neighborhood.length;
            return avgNeighborhood * 0.9; // Ajustar umbral ligeramente hacia abajo
        }

        // =====================================================
        // CONFIGURACIONES DIN√ÅMICAS DE OCR
        // =====================================================

        function getOptimalOCRConfig(imageAnalysis) {
            debugLog('=== CONFIGURANDO OCR DIN√ÅMICAMENTE ===');
            
            const documentType = imageAnalysis.documentType;
            const textDensity = imageAnalysis.textDensity;
            const hasTabularData = imageAnalysis.hasTabularData;
            
            let config = {
                tessedit_ocr_engine_mode: '1',
                preserve_interword_spaces: '1',
                textord_heavy_nr: '1',
                classify_enable_learning: '0',
                classify_enable_adaptive_matcher: '1'
            };
            
            // Configuraciones espec√≠ficas por tipo de documento
            if (documentType === 'invoice') {
                config.tessedit_pageseg_mode = '6'; // Uniform text block
                config.tessedit_char_whitelist = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:‚Ç¨$%/-()[]';
                config.textord_tabfind_find_tables = '1';
                debugLog('Configuraci√≥n optimizada para FACTURA');
                
            } else if (documentType === 'form') {
                config.tessedit_pageseg_mode = '12'; // Sparse text
                config.preserve_interword_spaces = '0';
                config.tessedit_char_whitelist = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,;:-()[]√°√©√≠√≥√∫√º√±√Å√â√ç√ì√ö√ú√ë ';
                debugLog('Configuraci√≥n optimizada para FORMULARIO');
                
            } else if (documentType === 'contract') {
                config.tessedit_pageseg_mode = '1'; // Auto with OSD
                config.textord_min_linesize = '2.5';
                config.language_model_penalty_non_dict_word = '0.15';
                debugLog('Configuraci√≥n optimizada para CONTRATO');
                
            } else if (hasTabularData) {
                config.tessedit_pageseg_mode = '6';
                config.textord_tabfind_find_tables = '1';
                config.preserve_interword_spaces = '0';
                debugLog('Configuraci√≥n optimizada para DATOS TABULARES');
                
            } else if (textDensity < 0.3) {
                config.tessedit_pageseg_mode = '11'; // Sparse text
                config.textord_heavy_nr = '0';
                debugLog('Configuraci√≥n optimizada para TEXTO DISPERSO');
                
            } else {
                config.tessedit_pageseg_mode = '1'; // Auto with OSD
                debugLog('Configuraci√≥n GENERAL');
            }
            
            // Ajustes adicionales basados en calidad de imagen
            if (imageAnalysis.imageQuality.quality === 'poor') {
                config.tessedit_write_images = '1';
                config.classify_enable_adaptive_matcher = '0';
                debugLog('Ajustes para imagen de BAJA CALIDAD');
            }
            
            debugLog(`Configuraci√≥n final: ${JSON.stringify(config, null, 2)}`);
            return config;
        }

        // =====================================================
        // POST-PROCESAMIENTO CONTEXTUAL AVANZADO
        // =====================================================

        function postProcessText(text, documentType, confidence) {
            if (!text) return '';
            
            debugLog('=== INICIANDO POST-PROCESAMIENTO CONTEXTUAL ===');
            debugLog(`Tipo: ${documentType}, Confianza: ${confidence}%, Texto original: ${text.length} chars`);

            let processed = text;
            
            // PASO 1: Limpieza b√°sica mejorada
            processed = basicTextCleaning(processed);
            
            // PASO 2: Correcci√≥n contextual seg√∫n tipo de documento
            processed = contextualCorrection(processed, documentType);
            
            // PASO 3: Correcci√≥n ortogr√°fica inteligente
            processed = intelligentSpellCheck(processed);
            
            // PASO 4: Estructuraci√≥n autom√°tica
            processed = autoStructure(processed, documentType);
            
            // PASO 5: Validaci√≥n final y limpieza
            processed = finalValidation(processed, confidence);
            
            debugLog(`Post-procesamiento completado: ${processed.length} chars`);
            return processed;
        }

        function basicTextCleaning(text) {
            let cleaned = text;
            
            // Eliminar caracteres de control y espacios extra√±os
            cleaned = cleaned.replace(/[\x00-\x1F\x7F]/g, '');
            
            // Normalizar espacios
            cleaned = cleaned.replace(/\s+/g, ' ');
            
            // Eliminar l√≠neas vac√≠as m√∫ltiples
            cleaned = cleaned.replace(/\n\s*\n\s*\n/g, '\n\n');
            
            // Corregir puntuaci√≥n pegada
            cleaned = cleaned.replace(/([a-z√°√©√≠√≥√∫√º√±])([.,:;!?])/gi, '$1$2');
            cleaned = cleaned.replace(/([.,:;!?])([A-Z√Å√â√ç√ì√ö√ú√ë])/g, '$1 $2');
            
            return cleaned.trim();
        }

        function contextualCorrection(text, documentType) {
            const documentPatterns = DOCUMENT_PATTERNS[documentType] || DOCUMENT_PATTERNS.general;
            let corrected = text;
            
            // Aplicar correcciones espec√≠ficas del tipo de documento
            documentPatterns.corrections.forEach(correction => {
                corrected = corrected.replace(correction.pattern, correction.replacement);
            });
            
            // Correcciones generales de OCR
            const generalCorrections = [
                // N√∫meros com√∫nmente mal reconocidos
                { pattern: /\b[0O][0O]\b/g, replacement: '00' },
                { pattern: /\b[1I][0O]\b/g, replacement: '10' },
                { pattern: /\b[2Z][0O]\b/g, replacement: '20' },
                
                // Letras com√∫nmente mal reconocidas
                { pattern: /\brn\b/g, replacement: 'm' },
                { pattern: /\bvv\b/g, replacement: 'w' },
                { pattern: /\bcl\b/g, replacement: 'd' },
                
                // Caracteres especiales
                { pattern: /\|\|/g, replacement: 'll' },
                { pattern: /\|/g, replacement: 'l' },
                { pattern: /¬®/g, replacement: '"' },
                { pattern: /`/g, replacement: "'" },
                { pattern: /¬¥/g, replacement: "'" }
            ];
            
            generalCorrections.forEach(correction => {
                corrected = corrected.replace(correction.pattern, correction.replacement);
            });
            
            return corrected;
        }

        function intelligentSpellCheck(text) {
            const words = text.split(/\s+/);
            const correctedWords = words.map(word => {
                const cleanWord = word.replace(/[^\w]/g, '').toLowerCase();
                
                // Solo corregir si la palabra no est√° en el diccionario com√∫n
                if (cleanWord.length > 2 && !SPANISH_DICTIONARY.common_words.includes(cleanWord)) {
                    return correctWord(word, cleanWord);
                }
                return word;
            });
            
            return correctedWords.join(' ');
        }

        function correctWord(originalWord, cleanWord) {
            // Correcciones comunes basadas en distancia de edici√≥n
            const commonCorrections = {
                'recibo': ['recib0', 'recib¬©', 'rec1bo'],
                'n√∫mero': ['numer0', 'num3ro', 'n√ªmero'],
                'fecha': ['fech4', 'f3cha', 'fecha'],
                'total': ['t0tal', 'to‚Ä†al', 'tota1'],
                'precio': ['preci0', 'pr3cio', 'precio'],
                'cantidad': ['cantid4d', 'c4ntidad', 'cantidad'],
                'cliente': ['c1iente', 'clien‚Ä†e', 'cliente'],
                'empresa': ['empr3sa', 'empres√¢', 'empresa'],
                'direcci√≥n': ['direcci0n', 'direccion', 'direcci√≥n'],
                'tel√©fono': ['telefon0', '‚Ä†elefono', 'tel√©fono']
            };
            
            // Buscar coincidencias
            for (const [correct, variants] of Object.entries(commonCorrections)) {
                if (variants.some(variant => variant.toLowerCase() === cleanWord)) {
                    return originalWord.replace(new RegExp(cleanWord, 'gi'), correct);
                }
            }
            
            return originalWord;
        }

        function autoStructure(text, documentType) {
            let structured = text;
            
            // Detectar y formatear n√∫meros y fechas
            structured = formatNumbersAndDates(structured);
            
            // Estructurar seg√∫n tipo de documento
            if (documentType === 'invoice') {
                structured = structureInvoice(structured);
            } else if (documentType === 'form') {
                structured = structureForm(structured);
            } else {
                structured = structureGeneral(structured);
            }
            
            return structured;
        }

        function formatNumbersAndDates(text) {
            let formatted = text;
            
            // Formatear fechas (DD/MM/YYYY, DD-MM-YYYY)
            formatted = formatted.replace(/\b(\d{1,2})[\/\-.](\d{1,2})[\/\-.](\d{2,4})\b/g, '$1/$2/$3');
            
            // Formatear n√∫meros con decimales
            formatted = formatted.replace(/\b(\d+)[,.](\d{2})\s*‚Ç¨\b/g, '$1,$2 ‚Ç¨');
            formatted = formatted.replace(/\b(\d+)[,.](\d{2})\s*\$\b/g, '$1.$2 $');
            
            // Formatear c√≥digos postales
            formatted = formatted.replace(/\b(\d{5})\b/g, '$1');
            
            return formatted;
        }

        function structureInvoice(text) {
            // Estructurar facturas con secciones identificables
            let structured = text;
            
            // Identificar secciones comunes de facturas
            structured = structured.replace(/\b(FACTURA|INVOICE)\b/gi, '\n=== $1 ===\n');
            structured = structured.replace(/\b(TOTAL|SUBTOTAL|IVA|TAX)\s*:?\s*([0-9.,]+\s*[‚Ç¨$]?)/gi, '\n$1: $2');
            structured = structured.replace(/\b(FECHA|DATE)\s*:?\s*([0-9\/\-]+)/gi, '\n$1: $2');
            
            return structured;
        }

        function structureForm(text) {
            // Estructurar formularios con campos y valores
            let structured = text;
            
            // Detectar campos de formulario
            const formFields = ['NOMBRE', 'APELLIDO', 'DIRECCI√ìN', 'TEL√âFONO', 'EMAIL', 'FECHA', 'DNI', 'NIF'];
            
            formFields.forEach(field => {
                const regex = new RegExp(`\\b(${field})\\s*:?\\s*([A-Za-z0-9@._\\s-]+)`, 'gi');
                structured = structured.replace(regex, `\n${field}: $2`);
            });
            
            return structured;
        }

        function structureGeneral(text) {
            // Estructurar texto general mejorando p√°rrafos
            let structured = text;
            
            // Mejorar separaci√≥n de p√°rrafos
            structured = structured.replace(/\.\s*([A-Z√Å√â√ç√ì√ö√ú√ë])/g, '.\n\n$1');
            
            // Detectar listas
            structured = structured.replace(/^(\d+[\.\)]|\-|\*)\s*/gm, '\n$1 ');
            
            return structured;
        }

        function finalValidation(text, confidence) {
            let validated = text;
            
            // Si la confianza es baja, mantener formato m√°s conservador
            if (confidence < 70) {
                // Menos procesamiento agresivo para texto de baja confianza
                validated = validated.replace(/\n{3,}/g, '\n\n');
            }
            
            // Limpieza final
            validated = validated.replace(/^\s+|\s+$/g, '');
            validated = validated.replace(/\n\s*\n\s*\n/g, '\n\n');
            
            return validated;
        }

        // =====================================================
        // FUNCIONES PRINCIPALES MODIFICADAS
        // =====================================================

        // Inicializaci√≥n
        document.addEventListener('DOMContentLoaded', function() {
            video = document.getElementById('video');
            canvas = document.getElementById('canvas');
            ctx = canvas.getContext('2d');
            
            initKeyboardShortcuts();
            checkTesseractAvailability();
        });

        function checkTesseractAvailability() {
            const checkInterval = setInterval(() => {
                if (typeof Tesseract !== 'undefined') {
                    clearInterval(checkInterval);
                    showStatus('success', '‚úÖ Tesseract.js cargado correctamente. Sistema OCR v2.0 listo.');
                    debugLog('Tesseract.js disponible - versi√≥n avanzada');
                } else {
                    showStatus('info', '‚è≥ Cargando sistema OCR avanzado...');
                }
            }, 500);

            setTimeout(() => {
                if (typeof Tesseract === 'undefined') {
                    clearInterval(checkInterval);
                    showStatus('error', '‚ùå Error: No se pudo cargar el sistema OCR. Verifica tu conexi√≥n.');
                }
            }, 10000);
        }

        // Gesti√≥n de C√°mara (sin cambios)
        async function toggleCamera() {
            const btn = document.getElementById('cameraBtn');
            
            if (stream) {
                stopCamera();
            } else {
                try {
                    await startCamera();
                } catch (error) {
                    showStatus('error', `Error al acceder a la c√°mara: ${error.message}`);
                }
            }
        }

        async function startCamera() {
            try {
                if (!navigator.mediaDevices || !navigator.mediaDevices.getUserMedia) {
                    throw new Error('Tu navegador no soporta acceso a la c√°mara');
                }

                const constraints = {
                    video: {
                        facingMode: currentCamera,
                        width: { ideal: 1920, min: 1280 },
                        height: { ideal: 1080, min: 720 },
                        frameRate: { ideal: 30 }
                    }
                };

                stream = await navigator.mediaDevices.getUserMedia(constraints);
                video.srcObject = stream;
                
                video.style.display = 'block';
                canvas.style.display = 'none';
                document.getElementById('cameraOverlay').style.display = 'block';
                document.getElementById('imagePreview').style.display = 'none';
                document.getElementById('documentTypeIndicator').style.display = 'none';
                
                document.getElementById('cameraBtn').textContent = '‚èπÔ∏è Detener C√°mara';
                document.getElementById('flipBtn').disabled = false;
                document.getElementById('captureBtn').disabled = false;
                
                showStatus('info', 'üì∑ C√°mara activa. Sistema OCR v2.0 preparado para an√°lisis inteligente.');
                debugLog(`C√°mara iniciada: ${video.videoWidth}x${video.videoHeight}`);
                
            } catch (error) {
                let errorMessage = 'Error al acceder a la c√°mara';
                
                if (error.name === 'NotAllowedError') {
                    errorMessage = 'Permiso denegado. Permite el acceso a la c√°mara.';
                } else if (error.name === 'NotFoundError') {
                    errorMessage = 'No se encontr√≥ c√°mara en el dispositivo.';
                } else if (error.name === 'NotReadableError') {
                    errorMessage = 'La c√°mara est√° siendo usada por otra aplicaci√≥n.';
                }
                
                throw new Error(errorMessage);
            }
        }

        function stopCamera() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
                stream = null;
                video.srcObject = null;
                
                video.style.display = 'none';
                document.getElementById('cameraOverlay').style.display = 'none';
                
                document.getElementById('cameraBtn').textContent = 'üì∑ Iniciar C√°mara';
                document.getElementById('flipBtn').disabled = true;
                document.getElementById('captureBtn').disabled = true;
                
                clearStatus();
            }
        }

        async function flipCamera() {
            currentCamera = currentCamera === 'environment' ? 'user' : 'environment';
            
            if (stream) {
                stopCamera();
                await startCamera();
            }
        }

        // Captura y procesamiento OCR MEJORADO
        async function captureAndProcess() {
            if (!stream || isProcessing) return;

            if (typeof Tesseract === 'undefined') {
                showStatus('error', '‚ùå Sistema OCR no disponible. Recarga la p√°gina.');
                return;
            }

            isProcessing = true;
            document.getElementById('captureBtn').disabled = true;

            try {
                // Efecto flash
                const flash = document.getElementById('flashEffect');
                flash.style.opacity = '0.8';
                setTimeout(() => flash.style.opacity = '0', 150);

                if (video.videoWidth === 0 || video.videoHeight === 0) {
                    throw new Error('El video no est√° listo. Espera un momento.');
                }

                debugLog(`=== INICIANDO CAPTURA Y PROCESAMIENTO v2.0 ===`);
                debugLog(`Capturando imagen: ${video.videoWidth}x${video.videoHeight}`);

                // Capturar con m√°xima calidad
                canvas.width = video.videoWidth;
                canvas.height = video.videoHeight;
                
                ctx.imageSmoothingEnabled = true;
                ctx.imageSmoothingQuality = 'high';
                ctx.drawImage(video, 0, 0);

                // Mostrar imagen capturada
                video.style.display = 'none';
                canvas.style.display = 'block';
                document.getElementById('cameraOverlay').style.display = 'none';
                
                // Mostrar preview
                const previewImg = document.getElementById('previewImg');
                previewImg.src = canvas.toDataURL('image/jpeg', 0.95);
                document.getElementById('imagePreview').style.display = 'block';

                // Procesar con sistema avanzado
                await processOCRWithAdvancedSystem();

            } catch (error) {
                console.error('Error en captura:', error);
                showStatus('error', `Error: ${error.message}`);
            } finally {
                isProcessing = false;
                document.getElementById('captureBtn').disabled = false;
            }
        }

        // FUNCI√ìN PRINCIPAL DE PROCESAMIENTO OCR AVANZADO
        async function processOCRWithAdvancedSystem() {
            const startTime = performance.now();
            
            showProgress(0, 'Iniciando an√°lisis inteligente...');
            
            try {
                // PASO 1: An√°lisis previo de la imagen
                showProgress(5, 'Analizando tipo de documento...');
                const imageAnalysis = await analyzeImage(canvas);
                
                // Mostrar tipo de documento detectado
                document.getElementById('documentType').textContent = 
                    imageAnalysis.documentType.toUpperCase();
                document.getElementById('documentTypeIndicator').style.display = 'block';
                
                debugLog(`Documento detectado: ${imageAnalysis.documentType}`);

                // PASO 2: Validar calidad de imagen
                showProgress(10, 'Validando calidad de imagen...');
                if (!validateImageQuality(canvas)) {
                    hideProgress();
                    return;
                }

                // PASO 3: Inicializar worker si no existe
                if (!worker) {
                    showProgress(15, 'Inicializando sistema OCR avanzado...');
                    await initializeOCRWorker();
                }

                // PASO 4: Preprocesamiento avanzado
                showProgress(20, 'Optimizando imagen inteligentemente...');
                const processedCanvas = await preprocessImageForOCR(canvas);
                
                // PASO 5: Configuraci√≥n din√°mica
                showProgress(45, 'Configurando OCR para este tipo de documento...');
                const optimalConfig = getOptimalOCRConfig(imageAnalysis);
                
                // PASO 6: OCR con configuraci√≥n optimizada
                showProgress(50, 'Extrayendo texto con m√°xima precisi√≥n...');
                const result = await worker.recognize(processedCanvas, optimalConfig);
                
                if (!result || !result.data) {
                    throw new Error('No se pudo extraer texto del documento');
                }

                // PASO 7: Post-procesamiento contextual
                showProgress(85, 'Limpiando y estructurando texto...');
                const rawText = result.data.text || '';
                const confidence = result.data.confidence || 0;
                
                const processedText = postProcessText(rawText, imageAnalysis.documentType, confidence);

                showProgress(100, 'Completado');
                hideProgress();

                // Mostrar resultados
                document.getElementById('extractedText').value = processedText;
                updateConfidence(confidence);
                document.getElementById('textSection').style.display = 'block';

                // Actualizar estad√≠sticas
                const processingTime = (performance.now() - startTime) / 1000;
                updateStats(confidence, processingTime);

                // Mensaje de estado mejorado
                let statusMessage = `‚úÖ Texto extra√≠do: ${processedText.length} caracteres`;
                statusMessage += ` (${Math.round(confidence)}% confianza, ${processingTime.toFixed(1)}s)`;
                
                if (confidence >= 90) {
                    statusMessage = 'üéØ ' + statusMessage + ' - Excelente precisi√≥n!';
                } else if (confidence >= 70) {
                    statusMessage = 'üëç ' + statusMessage + ' - Buena precisi√≥n';
                } else {
                    statusMessage = '‚ö†Ô∏è ' + statusMessage + ' - Considera mejorar la imagen';
                }
                
                showStatus('success', statusMessage);
                debugLog(`=== PROCESAMIENTO COMPLETADO EXITOSAMENTE ===`);

            } catch (error) {
                hideProgress();
                console.error('Error en OCR avanzado:', error);
                showStatus('error', `‚ùå Error en procesamiento: ${error.message}`);
                debugLog(`Error completo: ${error.toString()}`);
                
                // Reinicializar worker si fall√≥
                if (worker) {
                    try {
                        await worker.terminate();
                        worker = null;
                        debugLog('Worker reinicializado tras error');
                    } catch (termError) {
                        debugLog(`Error terminando worker: ${termError.message}`);
                    }
                }
            }
        }

        async function initializeOCRWorker() {
            try {
                debugLog('Inicializando worker OCR avanzado...');
                
                worker = await Tesseract.createWorker({
                    logger: m => {
                        if (m.status === 'recognizing text') {
                            const progress = 50 + (m.progress * 35); // 50-85%
                            showProgress(progress, `Reconociendo texto: ${Math.round(m.progress * 100)}%`);
                        }
                        debugLog(`Tesseract: ${m.status} - ${m.progress || ''}`);
                    }
                });

                await worker.loadLanguage('spa+eng');
                await worker.initialize('spa+eng');

                debugLog('Worker OCR avanzado inicializado correctamente');
                
            } catch (error) {
                debugLog(`Error inicializando worker: ${error.message}`);
                throw new Error(`Error al inicializar OCR: ${error.message}`);
            }
        }

        function validateImageQuality(canvas) {
            const ctx = canvas.getContext('2d');
            const imageData = ctx.getImageData(0, 0, canvas.width, canvas.height);
            const data = imageData.data;
            
            let totalBrightness = 0;
            let pixels = 0;
            
            for (let i = 0; i < data.length; i += 4) {
                const brightness = (data[i] + data[i + 1] + data[i + 2]) / 3;
                totalBrightness += brightness;
                pixels++;
            }
            
            const avgBrightness = totalBrightness / pixels;
            
            debugLog(`Calidad de imagen - Brillo promedio: ${avgBrightness.toFixed(1)}`);
            
            if (avgBrightness < 50) {
                showStatus('error', '‚ö†Ô∏è Imagen muy oscura. Mejora la iluminaci√≥n para mejor OCR.');
                return false;
            } else if (avgBrightness > 200) {
                showStatus('error', '‚ö†Ô∏è Imagen muy clara. Reduce la exposici√≥n para mejor OCR.');
                return false;
            }
            
            return true;
        }

        // Utilidades de interfaz (sin cambios mayores)
        function showProgress(percentage, text) {
            const container = document.getElementById('progressContainer');
            const fill = document.getElementById('progressFill');
            const textEl = document.getElementById('progressText');
            
            container.style.display = 'block';
            fill.style.width = percentage + '%';
            textEl.textContent = text;
        }

        function hideProgress() {
            document.getElementById('progressContainer').style.display = 'none';
        }

        function updateConfidence(confidence) {
            const fill = document.getElementById('confidenceFill');
            const percentage = Math.round(confidence);
            fill.style.width = percentage + '%';
        }

        function updateStats(confidence, time) {
            stats.processed++;
            stats.confidenceSum += confidence;
            stats.timeSum += time;

            document.getElementById('docsProcessed').textContent = stats.processed;
            document.getElementById('avgConfidence').textContent = 
                Math.round(stats.confidenceSum / stats.processed) + '%';
            document.getElementById('avgTime').textContent = 
                (stats.timeSum / stats.processed).toFixed(1) + 's';
        }

        function copyToClipboard() {
            const text = document.getElementById('extractedText').value;
            if (navigator.clipboard) {
                navigator.clipboard.writeText(text).then(() => {
                    showStatus('success', 'üìã Texto copiado al portapapeles');
                });
            } else {
                const textArea = document.createElement('textarea');
                textArea.value = text;
                document.body.appendChild(textArea);
                textArea.select();
                document.execCommand('copy');
                document.body.removeChild(textArea);
                showStatus('success', 'üìã Texto copiado al portapapeles');
            }
        }

        function retakePhoto() {
            document.getElementById('textSection').style.display = 'none';
            document.getElementById('imagePreview').style.display = 'none';
            document.getElementById('documentTypeIndicator').style.display = 'none';
            
            if (stream) {
                video.style.display = 'block';
                canvas.style.display = 'none';
                document.getElementById('cameraOverlay').style.display = 'block';
            }
            
            document.getElementById('extractedText').value = '';
            updateConfidence(0);
            clearStatus();
        }

        // Sistema de notificaciones
        function showStatus(type, message) {
            const container = document.getElementById('statusContainer');
            container.innerHTML = `
                <div class="status status-${type}">
                    ${message}
                </div>
            `;
            
            if (type === 'success') {
                setTimeout(clearStatus, 5000);
            }
            
            debugLog(`Status [${type}]: ${message}`);
        }

        function clearStatus() {
            document.getElementById('statusContainer').innerHTML = '';
        }

        // Debug
        function toggleDebug() {
            debugMode = !debugMode;
            const btn = event.target;
            const debugInfo = document.getElementById('debugInfo');
            
            if (debugMode) {
                btn.textContent = 'üêõ Debug: ON';
                btn.className = 'btn btn-success';
                debugInfo.style.display = 'block';
                showStatus('info', 'üêõ Modo debug activado - Sistema OCR v2.0');
            } else {
                btn.textContent = 'üêõ Modo Debug';
                btn.className = 'btn btn-secondary';
                debugInfo.style.display = 'none';
                debugInfo.innerHTML = '';
            }
        }

        function debugLog(message) {
            console.log('[DEBUG v2.0]', message);
            
            if (debugMode) {
                const debugInfo = document.getElementById('debugInfo');
                const timestamp = new Date().toLocaleTimeString();
                debugInfo.innerHTML += `[${timestamp}] ${message}\n`;
                debugInfo.scrollTop = debugInfo.scrollHeight;
            }
        }

        // Atajos de teclado
        function initKeyboardShortcuts() {
            document.addEventListener('keydown', function(e) {
                if (e.target.matches('input, textarea')) return;
                
                if (e.code === 'Space') {
                    e.preventDefault();
                    if (!document.getElementById('captureBtn').disabled && !isProcessing) {
                        captureAndProcess();
                    }
                }
                
                if (e.key === 'Escape') {
                    e.preventDefault();
                    retakePhoto();
                }
                
                if (e.ctrlKey && e.key === 'c' && document.getElementById('textSection').style.display !== 'none') {
                    copyToClipboard();
                }
                
                if (e.ctrlKey && e.key === 'd') {
                    e.preventDefault();
                    toggleDebug();
                }
            });
        }

        // Manejo de errores globales
        window.addEventListener('error', function(e) {
            console.error('Error global:', e.error);
            debugLog(`Error global: ${e.error?.message || e.message}`);
            
            if (!isProcessing) {
                showStatus('error', 'Se produjo un error inesperado. Revisa la consola.');
            }
        });

        // Limpieza al cerrar
        window.addEventListener('beforeunload', function() {
            if (stream) {
                stream.getTracks().forEach(track => track.stop());
            }
            if (worker) {
                worker.terminate();
            }
        });

        // =====================================================
        // FUNCIONES ADICIONALES DE MEJORA
        // =====================================================

        // An√°lisis de confianza por regiones
        function analyzeConfidenceByRegions(ocrResult) {
            if (!ocrResult.data.words) return [];
            
            const lowConfidenceWords = ocrResult.data.words.filter(word => 
                word.confidence < 70
            );
            
            debugLog(`Palabras con baja confianza: ${lowConfidenceWords.length}`);
            return lowConfidenceWords;
        }

        // Sugerencias de mejora autom√°ticas
        function provideFeedback(imageAnalysis, confidence) {
            const feedback = [];
            
            if (imageAnalysis.imageQuality.brightness < 80) {
                feedback.push('üí° Mejora: Aumenta la iluminaci√≥n');
            }
            
            if (imageAnalysis.imageQuality.brightness > 180) {
                feedback.push('üí° Mejora: Reduce la exposici√≥n');
            }
            
            if (confidence < 70) {
                feedback.push('üí° Mejora: Mant√©n el documento m√°s plano');
                feedback.push('üí° Mejora: Aseg√∫rate de que no haya sombras');
            }
            
            if (imageAnalysis.textDensity < 0.2) {
                feedback.push('üí° Mejora: Enfoca mejor la regi√≥n con texto');
            }
            
            return feedback;
        }

        // Procesamiento por lotes mejorado
        async function processMultipleRegions(canvas, textRegions) {
            const results = [];
            
            for (const region of textRegions) {
                try {
                    const regionCanvas = extractRegion(canvas, region);
                    const regionResult = await worker.recognize(regionCanvas);
                    results.push({
                        region,
                        text: regionResult.data.text,
                        confidence: regionResult.data.confidence
                    });
                } catch (error) {
                    debugLog(`Error procesando regi√≥n: ${error.message}`);
                }
            }
            
            return results;
        }

        function extractRegion(canvas, region) {
            const regionCanvas = document.createElement('canvas');
            regionCanvas.width = region.width;
            regionCanvas.height = region.height;
            const regionCtx = regionCanvas.getContext('2d');
            
            regionCtx.drawImage(canvas, 
                region.x, region.y, region.width, region.height,
                0, 0, region.width, region.height
            );
            
            return regionCanvas;
        }

        // Auto-guardado de configuraciones exitosas
        function saveSuccessfulConfig(documentType, config, confidence) {
            if (confidence > 85) {
                const savedConfigs = JSON.parse(localStorage.getItem('ocrConfigs') || '{}');
                savedConfigs[documentType] = {
                    config,
                    confidence,
                    timestamp: Date.now()
                };
                localStorage.setItem('ocrConfigs', JSON.stringify(savedConfigs));
                debugLog(`Configuraci√≥n guardada para ${documentType}: ${confidence}% confianza`);
            }
        }

        function loadSavedConfig(documentType) {
            const savedConfigs = JSON.parse(localStorage.getItem('ocrConfigs') || '{}');
            return savedConfigs[documentType]?.config || null;
        }

        // M√©tricas avanzadas de rendimiento
        function trackPerformanceMetrics(startTime, endTime, confidence, textLength) {
            const metrics = {
                processingTime: endTime - startTime,
                confidence,
                textLength,
                charactersPerSecond: textLength / ((endTime - startTime) / 1000),
                timestamp: Date.now()
            };
            
            // Guardar m√©tricas localmente para an√°lisis
            const allMetrics = JSON.parse(localStorage.getItem('ocrMetrics') || '[]');
            allMetrics.push(metrics);
            
            // Mantener solo las √∫ltimas 100 m√©tricas
            if (allMetrics.length > 100) {
                allMetrics.splice(0, allMetrics.length - 100);
            }
            
            localStorage.setItem('ocrMetrics', JSON.stringify(allMetrics));
            debugLog(`M√©tricas guardadas: ${JSON.stringify(metrics)}`);
        }

        // Funci√≥n de prueba para desarrolladores
        function runDiagnostics() {
            debugLog('=== EJECUTANDO DIAGN√ìSTICOS DEL SISTEMA ===');
            
            // Verificar Tesseract
            debugLog(`Tesseract disponible: ${typeof Tesseract !== 'undefined'}`);
            
            // Verificar c√°mara
            debugLog(`MediaDevices soportado: ${!!navigator.mediaDevices}`);
            
            // Verificar canvas
            const testCanvas = document.createElement('canvas');
            const ctx = testCanvas.getContext('2d');
            debugLog(`Canvas soportado: ${!!ctx}`);
            
            // Verificar almacenamiento local
            try {
                localStorage.setItem('test', 'test');
                localStorage.removeItem('test');
                debugLog('LocalStorage: Disponible');
            } catch (e) {
                debugLog('LocalStorage: No disponible');
            }
            
            // Mostrar m√©tricas hist√≥ricas
            const metrics = JSON.parse(localStorage.getItem('ocrMetrics') || '[]');
            if (metrics.length > 0) {
                const avgConfidence = metrics.reduce((sum, m) => sum + m.confidence, 0) / metrics.length;
                const avgTime = metrics.reduce((sum, m) => sum + m.processingTime, 0) / metrics.length;
                debugLog(`M√©tricas hist√≥ricas - Confianza promedio: ${avgConfidence.toFixed(1)}%, Tiempo promedio: ${avgTime.toFixed(1)}ms`);
            }
            
            debugLog('=== DIAGN√ìSTICOS COMPLETADOS ===');
        }

        // Exposer funci√≥n de diagn√≥sticos para desarrollo
        window.runOCRDiagnostics = runDiagnostics;

        // Mensaje de bienvenida mejorado
        setTimeout(() => {
            if (typeof Tesseract !== 'undefined') {
                showStatus('info', 'üöÄ Sistema OCR v2.0 listo con an√°lisis inteligente. Inicia la c√°mara para comenzar.');
                debugLog('Sistema OCR v2.0 completamente inicializado');
                
                // Mostrar tip aleatorio
                const tips = [
                    'üí° Tip: El sistema ahora detecta autom√°ticamente el tipo de documento',
                    'üí° Tip: Usa Ctrl+D para activar el modo debug avanzado', 
                    'üí° Tip: El post-procesamiento contextual mejora autom√°ticamente el texto'
                ];
                
                setTimeout(() => {
                    const randomTip = tips[Math.floor(Math.random() * tips.length)];
                    showStatus('info', randomTip);
                }, 3000);
            }
        }, 2000);

        // Auto-limpieza de datos antiguos
        function cleanupOldData() {
            const configs = JSON.parse(localStorage.getItem('ocrConfigs') || '{}');
            const metrics = JSON.parse(localStorage.getItem('ocrMetrics') || '[]');
            
            // Limpiar configuraciones de m√°s de 30 d√≠as
            const thirtyDaysAgo = Date.now() - (30 * 24 * 60 * 60 * 1000);
            
            Object.keys(configs).forEach(key => {
                if (configs[key].timestamp < thirtyDaysAgo) {
                    delete configs[key];
                }
            });
            
            localStorage.setItem('ocrConfigs', JSON.stringify(configs));
            
            // Mantener solo las √∫ltimas 50 m√©tricas
            if (metrics.length > 50) {
                const recentMetrics = metrics.slice(-50);
                localStorage.setItem('ocrMetrics', JSON.stringify(recentMetrics));
            }
        }

        // Ejecutar limpieza al cargar
        cleanupOldData();

        debugLog('=== SISTEMA OCR v2.0 INICIALIZADO ===');
        debugLog('Caracter√≠sticas habilitadas:');
        debugLog('- Detecci√≥n autom√°tica de tipo de documento');
        debugLog('- Configuraci√≥n OCR din√°mica');
        debugLog('- Post-procesamiento contextual');
        debugLog('- Preprocesamiento avanzado de imagen');
        debugLog('- Correcci√≥n ortogr√°fica inteligente');
        debugLog('- An√°lisis de calidad de imagen');
        debugLog('- M√©tricas de rendimiento');
        debugLog('=====================================');
    </script>
</body>
</html>